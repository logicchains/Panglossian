#Panglossian
=====

##Motivation
Current open world backends generally use what's termed a 'sharded' architecture, in which multiple servers run duplicate world instances ('shards') and user agents in one shard cannot interact comprehensively with those in other shards. Exceptions exist, such as the backend for Eve Online, as MMO space simulation in which all of the games hundreds of thousands of players exist in a single universe, however even in this case the architecture is limited to using no more than one server per solar system, resulting in significant performance degradation when a large number of players are clustered together.

The assumption behind this project is that it's possible to performantly simulate a massive, contiguous virtual world in a manner allowing for an extremely high resolution of servers per geographical area. This would allow for more realistic, immersive user experiences, via the economies of scale facilitated by having more user agents in a single world, and for complex social/economic/evolutionary/AI simulations. I'm more interested in the latter, but I aim for Panglossian to be generic and extensible enough to also be suitable for use as an MMO backend.

##Specification
A given world is defined by the action types and initial objects that exist within it. An object consists solely of a unique identifier and a collection of (property,value) pairs. An action consists of a collection of (property,value) pairs representing the properties are consumed in its application, another such collection representing those that are required but not consumed, a collection of special prerequisites ('scripts', described later), a collection of special effects (also scripts), an action point cost, and two collections of modifiers.

A modifier is a (property, multiplier, exponent) tuple, two collections of which are part of each action type. One describes how the action is affected by the actor's properties, while the other describes how the action is affected by the target's properties. An action X with actor modifier ("weight", 3, 2) and property ("weight", 5) would have its effect X.e increased to e\*(3\*5)^2, and the same would occur if it was a target modifier and the target had property "weight" with value five. Negative multiplier values are treated as division; ("weight", -3, 2) sets e to e/(3\*5)^2. An exponent value of 0 is special-cased such that if the modifier in the previous example was ("weight", 3, 0), e would be set to e+(3\*5); it changes the modification into an addition/subtraction, instead of a multiplication.

"Scripts" exist to describe ways an action can affect properties of the actor and target that cannot be described using the action's other functionality. They can access and perform any arbitrary modification to the properties of the actor and target. The "constraints" attached to an action type are also scripts, which must return true or false and have no side-effects. An example constraint that will be present in most actions is withinReach: the Euclidean distance between the actor and the target must be less than the actor's "reach" property. Scripts are compiled upon loading.

All scripts, action types, and initial world objects are loaded upon startup. Each property is then given a unique identifier, with the names associated with the properties being stored in an array where the string at index n in the array is the name of the property with uuid n. All string instances of properties in the action types and objects loaded are then replaced by the uuids of those properties. All scripts are similarly given a unique identifier that replaces all string references to them, and all action types are given an implicit uuid identifier equal to their position in the action type array, which action instances may refer to.

Overloading of action type, property and script names is not allowed. Action type and object uuids are assigned in a fixed order, currently ascending alphabetical. This is vital, so that different machines running the world can communicate about them (so that a particular action type will have the same uuid in all machines running the world).

On startup, each region host is given a collection of uuids from the master server (controller) that may be assigned to new objects that are created within that region. More object uuids may be requested from the controller, and this is the only way that object uuids may be obtained, to ensure that the same uuid isn't used for different objects at any point in the simulation. Object uuid zero is reserved for use in signifying an action is intended to create a new object.

New action types and scripts may be added at runtime. These may only be loaded by the controller, and then sent to region hosts and clients, to ensure that all regions and clients have equivalent copies with equivalent uuids.

An instance of an action type is termed an action. An action consists of the uuid of the target, the uuid of the actor, the action type, and a collection of the objects that the action is using to meet its prerequisites; the object uuids in this collection are arranged in an order such that the prerequisite property at index n in that action's type's list of prerequisite properties is at position n in the collection of utilise objects. The consumed property at m in the action's types list of prerequisite properties is at position m + $n in the action's collection of utilised objects, where $n is the length of the action's type's prerequisite property collection.

An action may produce a new object with properties equal to that action's properties consumed, which is done by setting the action's target uuid to zero. There are no 'object types'; objects are defined entirely by their properties.

Object typing may be achieved indirectly by defining specific properties that generally don't vary in value and which are not consumed. A property "food", for instance, could be used to identify objects that can be eaten, by having the action "eat" require the target possess this property. This kind of arrangement facilitates emergent behaviour in the case of AI: if in a social simulation actors were given the properties associated with food, for instance, then cannibalism would automatically be incorporated into the simulation. Properties may also be designated for use in certain runtime functions; a property 'actor' could be used to identify which objects are capable of taking actions (the runtime functions are described later). Similarly, renderers may determine how to render objects based on the properties they posses.

Each actor must also possess a property to designate action points (or alternatively, possession of the action points property could be used to signal that an object is an actor). All actions consume a certain amount of action points, and each 'turn' an actor may take as many actions as they have action points to support. Note that all the actions an actor takes in a particular turn are executed *in undefined order*. This is so that actions may be executed in parallel, and to greatly reduce the amount of inter-region communication required when an action takes place at a border between multiple regions.

Each client is polled at a regular interval, likely between one and ten seconds, by the region host with which it is registered. It is then given a fixed amount of time to send to the host all the actions it wishes to take. Note that in implementing this, clients will generally not communicate directly with region hosts, but rather will go through a proxy that's responsible solely for checking whether the client's authentication key is correct and whether it has authority to control the actions of the actors it attempts to control. This also simplifies movement between multiple regions connected to the same proxy, as the client does not have to reconnect; connecting to a different server is only necessary when the client is moving to a region that's not connected to the proxy that its previous region was connected to.

A client controlling actors in multiple regions not serviced by the same proxy must maintain multiple connections, one to each proxy. Proxies should be capable of dynamically adjusting the regions they service at runtime, when instructed to do so by the controller.

When a region host has received actions from all the clients to which it is connected (or the clients have timed out), it executes all the actions that do not occur in border regions, in no predetermined order. It then executes all actions in border regions, again in no predetermined order. It then exchanges with each neighbouring region all actions that involve objects on the "border region" its side of the border, and executes all the actions it received from its neighbours. The actions from its neighbours that are executed successfully are then sent back to its neighbours, and all actions of its that were successfully executed on its neighbours are received by it. Finally, all actions that were successfully executed in that region are sent back to all the clients connected to it that are either affected by or within discovery range (a runtime option) of each particular action.

A "border region" is any point in a region that is less than n distance to another region, where n is the maximum distance at which an actor can use an object (a runtime option). This is defined such that if an an action does not touch any objects on a border region, it is not engaged in any races against actors from other regions.

Note that this system is not 'fair'. An actor in a non-border region essentially gets to act before one in a border region, and an actor on the A side of the border between A and B gets to use objects on A side of the border before an actor on the B side of the border can. The justification for this is may be demonstrated with an example. Imagine an action "milkshake" that takes 10 "banana", 5 "milk" and 1 "yard". The banana is being taken from an object not in the border region of region A, the milk is being taken from an object on the border region of the A side of the border, and the yard is being taken from the border region on the B side of the border. Imagine this action is taken, and then an action "timber" in region B is taken that also tries to use the yard. Now imagine "timber" has precedence, and uses the yard, meaning the "milkshake" action in region A fails. This means the 10 "banana" is not consumed. What if there was another action earlier in that turn, "split", occurring after "milkshake" but before "timber", that had attempted to use the 10 "banana" but had failed? It should now succeed, but implementing this would required having either kept track of all actions that touched the "banana" object (essentially all actions that touched each object), or rescanning all failed actions to see which could now be completed. This is potentially quite time-consuming, especially considering that the success of "split" could potentially allow other action that had previously failed to succeed.

Executing first all actions that don't touch border region objects is a simple way to avoid the above scenario. This means that no actions taken in region B can cause non-border actions in region A to fail (and vice versa), greatly simplifying calculations. Similar reasons apply for giving actions using objects on the A side of the border between regions A and B precedence over actions from the B side that use those objects.

Note that this arrangement isn't perfect. Imagine two apples, appleA and appleB, on the A and B sides of the border between regions A and B respectively. Now imagine actions occur in both A and B (actA and actB respectively) that attempt to consume both appleA and appleB. ActA has precedence for use of appleA, but actB has precedence for use of appleB. What happens? Region A messages actA to region B and B messages actB to A. Region A executes actA before actB and sends region B a message that actB fails (well, doesn't send actB back to region B, which effectively signals failure), and region B executes actB first and notifies region A that actA fails. ActA and actB hence both fail, and appleA and appleB remain unconsumed.

I do not expect this to present a problem in practice, but alternative approaches are welcome. 
